# SPDX-License-Identifier: Apache-2.0
# See README.md for license details

import datetime
import glob
import json
import os
import random
import re
import select
import shutil
import subprocess
from flask import Flask, request, send_file, jsonify

def load_config(path):
    with open(path) as f:
        return json.load(f)

config = load_config('config/default.json')
cli_command = config['tool']['program_name'].split(' ')

app = Flask(__name__, static_url_path='', static_folder='static')

attack_console_sessions = {}

def generate_sessid():
    return ''.join(random.choice('0123456789abcdef') for _ in range(32))

def run_planner_cli(path_network, path_scanresult, attacking_host, target_host, target_state):
    cmdline = cli_command[:]
    cmdline += ['--plan']
    cmdline += ['-f', path_scanresult]
    cmdline += ['-nx', path_network]
    if attacking_host:
        cmdline += ['--initial-host', attacking_host]
    if target_host:
        cmdline += ['--goal-current-host', target_host]
        cmdline += ['--goal-name', f'intrude-into-{target_host}']
    if target_state:
        cmdline += ['--goal-current-status', target_state]
        cmdline += ['--goal-name', target_state]
    # execute the command silently
    cmdline += ['--treenum', '0']
    print(' '.join(cmdline))
    return subprocess.run(cmdline, cwd=config['tool']['program_dir'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

def run_executor_cli(path_attacktrees, tree_number, lhost):
    cmdline = cli_command[:]
    cmdline += ['--plan', '--execute']
    cmdline += ['--loadtrees', path_attacktrees]
    cmdline += ['--treenum', str(tree_number)]
    if lhost:
        cmdline += ['--lhost', lhost]
    # avoid stdout blocking
    env = os.environ.copy()
    env['PYTHONUNBUFFERED'] = 'x'
    print(' '.join(cmdline))
    return subprocess.Popen(cmdline, cwd=config['tool']['program_dir'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, env=env)

def get_param(name):
    if name in request.form:
        return request.form[name] or None

def get_latest_file(globpath):
    files = glob.glob(globpath)
    if not files:
        return None
    files.sort(key=lambda f: os.stat(f).st_mtime)
    return files[-1]

@app.route('/api/attack_path_search', methods=['POST'])
def attack_path_search():
    # obtain request parameters
    attacking_host = get_param('attackingHost')
    target_host = get_param('targetHost')
    target_state = get_param('targetState')
    # store uploaded files
    [file_network, file_scanresult] = request.files.getlist('files')
    file_network_name = 'network.xml'
    if file_scanresult.filename.endswith('.common'):
        file_scanresult_name = 'scan.common'
    elif file_scanresult.filename.endswith('.nessus'):
        file_scanresult_name = 'scan.nessus'
    elif file_scanresult.filename.endswith('.nmap'):
        file_scanresult_name = 'scan.nmap'
    else:
        raise ValueError('error: scan file name should end with .common/.nessus/.nmap')
    path_network = os.path.abspath(os.path.join(config['file']['upload'], file_network_name))
    path_scanresult = os.path.abspath(os.path.join(config['file']['upload'], file_scanresult_name))
    os.makedirs(os.path.dirname(path_network), exist_ok=True)
    file_network.save(path_network)
    file_scanresult.save(path_scanresult)

    # clean up result directory
    path_tooloutput = os.path.abspath(config['file']['tool_output'])
    shutil.rmtree(path_tooloutput, ignore_errors=True)
    os.makedirs(path_tooloutput, exist_ok=True)

    # invoke the cli program
    result = run_planner_cli(path_network, path_scanresult, attacking_host, target_host, target_state)
    if result.returncode != 0:
        # error while running A2P2V
        print(result.stdout.decode())
        return jsonify({'result': 'error', 'errorcode': result.returncode, 'error': result.stdout.decode()}), 500

    # retrieve generated JSON attack tree (result of cli program)
    path_cliresult = get_latest_file(os.path.join(path_tooloutput, 'attack_trees_*.json'))
    if not path_cliresult:
        return jsonify({'attackPathFilename': ''})
    path_id = datetime.datetime.utcnow().strftime('%Y%m%d%H%M%S%f')[:-3]
    path_cliresult_copy = os.path.abspath(os.path.join(config['file']['download'], f'result_{path_id}.json'))
    os.makedirs(os.path.dirname(path_cliresult_copy), exist_ok=True)
    shutil.copy(path_cliresult, path_cliresult_copy)

    return jsonify({'result': 'success', 'attackPathFilename': os.path.basename(path_cliresult_copy)})

@app.route('/api/attack_path_file_get', methods=['POST'])
def attack_path_file_get():
    result_filename = get_param('attackPathFilename')
    if result_filename is None:
        raise ValueError('error: attackPathFilename missing')
    if not re.match(r'[-_a-zA-Z0-9]+\.[-_a-zA-Z0-9]+', result_filename):
        raise ValueError('error: attackPathFilename format error')
    path_cliresult_copy = os.path.abspath(os.path.join(config['file']['download'], result_filename))
    res = send_file(path_cliresult_copy)
    os.remove(path_cliresult_copy)
    return res

@app.route('/api/executor/start', methods=['POST'])
def executor_start():
    sessid = generate_sessid()
    lhost = get_param('lhost')
    tree_number = get_param('treenum')
    [file_attacktrees] = request.files.getlist('attackPathJson')
    filename = 'attacktrees_' + sessid + '.json'
    path_attacktrees = os.path.abspath(os.path.join(config['file']['upload'], filename))
    os.makedirs(os.path.dirname(path_attacktrees), exist_ok=True)
    file_attacktrees.save(path_attacktrees)
    attack_console_sessions[sessid] = run_executor_cli(path_attacktrees, tree_number, lhost)
    return jsonify({'result': 'success', 'sessid': sessid})

@app.route('/api/executor/read_console/<sessid>', methods=['POST'])
def executor_read_console(sessid):
    if not (sessid in attack_console_sessions):
        return 'session not found', 404
    proc = attack_console_sessions[sessid]
    while True:
        # read executor process output
        buf = proc.stdout.readline()
        while len(select.select([proc.stdout.fileno()], [], [], 0)[0]) > 0:
            # if additional data is available immediately
            data = proc.stdout.readline()
            if not data:
                break
            buf += data
        if buf:
            lines = buf.decode().split('\n')
            if not lines[-1]:
                lines = lines[:-1]
            return jsonify({'result': 'success', 'lines': lines})
        if proc.poll() is not None:
            # process execution completed
            del attack_console_sessions[sessid]
            return jsonify({'result': 'complete', 'returncode': proc.returncode})

@app.route('/api/executor/stop/<sessid>', methods=['POST'])
def executor_stop(sessid):
    if not (sessid in attack_console_sessions):
        return 'session not found', 404
    proc = attack_console_sessions[sessid]
    proc.terminate()
    return jsonify({'result': 'success'})

@app.route('/', methods=['GET'])
def index():
    return app.send_static_file('index.html')

if __name__ == '__main__':
    app.run(config['server']['host'], config['server']['port'])
