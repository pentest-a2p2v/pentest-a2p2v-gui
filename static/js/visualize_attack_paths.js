// SPDX-License-Identifier: Apache-2.0
// See README.md for license details

/********************************************************************************/
/*                   Definition of constants and variables                      */
/********************************************************************************/

var network_xml_dom_ = "";
var import_xml_file_ = false;
var import_scan_result_file_ = false;
var scan_result_data_;

/********************************************************************************/
/*                         Definition of functions                              */
/********************************************************************************/
// Initialize (Called when page load or reload)
function init() {
  //loadingTimer_ = setInterval(setClock, 500);
  document.getElementById("visualization_import_button").disabled = true;
  document.getElementById("import_button").disabled = true;
}

function visualization_openFile_xml() {
  var xml_file = document.getElementById('visualization_xml_file');

  xml_file.onchange = function () {
    var xml_file = document.getElementById('visualization_xml_file');
    var xml_text = document.getElementById('visualization_xml_text');
    if (xml_file.files.length != 1) {
      alert('Please select one network configuration file');
      xml_text.value = "";
      document.getElementById("visualization_import_button").disabled = true;
      return;
    }
    else {
      xml_text.value = xml_file.files[0].name;
      if (document.getElementById('visualization_xml_text').value != "" &&
        document.getElementById('route_text').value != "") {
        document.getElementById("visualization_import_button").disabled = false;
      }
    }
  }
  xml_file.click();
}

function openFile_route() {
  var scan_result_file = document.getElementById('route_file');

  scan_result_file.onchange = function () {
    var route_file = document.getElementById('route_file');
    var route_file_text = document.getElementById('route_text');
    if (route_file.files.length != 1) {
      alert('Please select one attack path file');
      route_file_text.value = "";
      document.getElementById("visualization_import_button").disabled = true;
      return;
    }
    else {
      route_file_text.value = route_file.files[0].name;
      if (document.getElementById('visualization_xml_text').value != "" &&
        document.getElementById('route_text').value != "") {
        document.getElementById("visualization_import_button").disabled = false;
      }
    }
  }
  route_file.click();
}

// Open log file
function openFile_xml() {
  var xml_file = document.getElementById('xml_file');

  xml_file.onchange = function () {
    var xml_file = document.getElementById('xml_file');
    var xml_text = document.getElementById('xml_text');
    if (xml_file.files.length != 1) {
      alert('Please select one network configuration file');
      xml_text.value = "";
      document.getElementById("import_button").disabled = true;
      return;
    }
    else {
      xml_text.value = xml_file.files[0].name;
      if (document.getElementById('xml_text').value != "" &&
        document.getElementById('scan_result_text').value != "") {
        document.getElementById("import_button").disabled = false;
      }
    }
  }
  xml_file.click();
}

function openFile_scan_result() {
  var scan_result_file = document.getElementById('scan_result_file');

  scan_result_file.onchange = function () {
    var scan_result_file = document.getElementById('scan_result_file');
    var scan_result_text = document.getElementById('scan_result_text');
    if (scan_result_file.files.length != 1) {
      alert('Please select one scan result file');
      scan_result_text.value = "";
      document.getElementById("import_button").disabled = true;
      return;
    }
    else {
      scan_result_text.value = scan_result_file.files[0].name;
      if (document.getElementById('xml_text').value != "" &&
        document.getElementById('scan_result_text').value != "") {
        document.getElementById("import_button").disabled = false;
      }
    }
  }
  scan_result_file.click();
}

function import_files(xml_id, json_id, kind) {
  import_scan_result_file_ = false;
  var scan_result_file = document.getElementById(json_id);
  getScanResultData(scan_result_file.files[0], kind);
  network_xml_dom_ = "";
  import_xml_file_ = false;
  var xml_file = document.getElementById(xml_id);
  getXMLData(xml_file.files[0]);
  setTimeout(function () {
    waitForGetData(kind);
  }, 100);
}

function waitForGetData(kind) {
  if (import_xml_file_ == true) {
    document.getElementById('file_import').style.display = "none";
    //visualize
    $("#sc_tabs").empty();
    if (kind == 1) {
      var graph_parameters = analyzeNetworkGraph(network_xml_dom_);
      if (graph_parameters != null) {
        analyzeAndDrawAttackPath(scan_result_data_, graph_parameters);
      }
      document.getElementById('file_import').style.display = 'none';
      document.getElementById('network_disp').style.display = 'none';
      document.getElementById('network_attack').style.display = 'block';
    }
    //frontend
    if (kind == 2) {
      var network_canvas = document.getElementById('network0');
      network_canvas.style.visibility = 'hidden';
      var graph_parameters = analyzeNetworkGraph(network_xml_dom_);
      $('#attacking_host').empty();
      $('#target_host').empty();
      if (graph_parameters != null) {
        document.getElementById("search_button").disabled = false;
        drawNetworkGraph('network0', graph_parameters);
        makeAttackingParamaetersMenu(graph_parameters.hosts);
        network_canvas.style.visibility = 'visible';
      } else {
        document.getElementById("search_button").disabled = true;
      }
      document.getElementById('file_import').style.display = 'none';
      document.getElementById('network_disp').style.display = 'block';
      document.getElementById('network_attack').style.display = 'none';
      document.getElementById('back_to_network_button').style.display = 'inline';
    }
  }
  else {
    setTimeout(function () {
      waitForGetData();
    }, 100);
  }
}

function getXMLData(xm_file) {
  const reader = new FileReader();
  reader.onload = function (e) {
    var text = e.target.result;
    const parser = new DOMParser();
    network_xml_dom_ = parser.parseFromString(text, "text/xml");
    import_xml_file_ = true;
  }
  reader.onerror = function (e) {
    var errmes = new Array(
      "",
      "file not found.",
      "a security error is detected.",
      "file reading interrupted.",
      "do not have read permission for the file.",
      "file size is too large.",
      "unknown error.",
      "unknown error.",
      "file not found."
    );
    alert(errmes[reader.error.code] + "::" + log_text);
  }
  reader.readAsText(xm_file);
}

function getScanResultData(json_file, kind) {
  const reader = new FileReader();
  reader.onload = function (e) {
    var text = e.target.result;
    if (kind == 1) { scan_result_data_ = JSON.parse(text); }
    import_scan_result_file_ = true;
  }
  reader.onerror = function (e) {
    var errmes = new Array(
      "",
      "file not found.",
      "a security error is detected.",
      "file reading interrupted.",
      "do not have read permission for the file.",
      "file size is too large.",
      "unknown error.",
      "unknown error.",
      "file not found."
    );
    alert(errmes[reader.error.code] + "::" + log_text);
    import_scan_result_file_ = true;
  }
  reader.readAsText(json_file);
}

var attack_step_texts = []; // { tab_number, step, option, attack_text }

function addAttackPathStep(tab_number, div_id, current_host, hop, step) {
  var attack_step_div = document.getElementById(div_id);
  // label
  var newGrid = document.createElement('div');
  newGrid.style.display = 'grid';
  newGrid.style.gridTemplateColumns = '40% 60%';
  newGrid.style.margin = '0.5em 0';
  var newLabel = document.createElement('label');
  newLabel.innerText = "Attack Hop " + step + ' (' + current_host.host + ' \u2192 ' + hop.node + ')';
  newLabel.style.padding = '0 0.5em';
  newGrid.appendChild(newLabel);
  // dropdown menu & value
  var newSelect = document.createElement('select');
  newSelect.style.maxWidth = '90%';
  newSelect.id = newLabel.for = div_id + "_" + step;
  newSelect.setAttribute('tab_number', tab_number);
  newSelect.setAttribute('step', step);
  newSelect.setAttribute('option', option_value);
  newSelect.onchange = onAttackPathStepSelected;
  var option_value = 1;
  for (option_item of hop.options) {
    var newOption = document.createElement("option");
    newOption.text = option_item.capability;
    newOption.value = option_value;
    newSelect.appendChild(newOption);
    var attack_commands = [];
    for (action_item of option_item.actions) {
      if (!(action_item.value)) {
        continue;
      }
      //values is blank
      var action_values_check_blank = action_item.value.trim().split(' ');
      if ((action_values_check_blank.length == 1) && (action_values_check_blank[0].trim() == "")) {
        continue;
      }

      var action_values = action_item.value.split(' ');

      for (value_item of action_values) {
        var idx = value_item.indexOf('=');
        if (idx >= 0) {
          var key = value_item.substring(0, idx);
          var value = value_item.substring(idx+1);
          if (key.toLowerCase() == 'module') {
            // Module name: module=foo/bar/baz
            attack_commands.push(['msf>', 'use ' + value]);
          } else {
            // Options: param=value
            attack_commands.push(['msf>', 'set ' + key + ' ' + value]);
          }
        } else {
          // unexpected parameter
          attack_commands.push(['msf>', value_item]);
        }
      }
      attack_commands.push(['msf>', 'exploit']);
    }
    var attack_text = attack_commands.map((v) => v.join(' ')).join('\n')
    var attack_step_text_item = {
      tab_number: tab_number, step: step,
      option: option_value, attack_text: attack_text
    }
    attack_step_texts.push(attack_step_text_item);
    option_value++;
  }
  newGrid.appendChild(newSelect);
  attack_step_div.appendChild(newGrid);
  // value
  var selected_attack_text = attack_step_texts.find((v) =>
    (v.tab_number == tab_number) &&
    (v.step == step) &&
    (v.option == 1)).attack_text;
  var newTextArea = document.createElement('textarea');
  newTextArea.readOnly = true;
  newTextArea.value = selected_attack_text;
  newTextArea.setAttribute('id', 'TAB_' + tab_number + '_step_' + step);
  newTextArea.style.width = '90%';
  newTextArea.style.marginLeft = '5%';
  newTextArea.style.marginRight = '5%';
  newTextArea.style.height = '10vh';
  newTextArea.style.border = 'solid 1px royalblue';
  newTextArea.style.fontFamily = 'Consolas, "DejaVu Sans Mono", monospace';
  newTextArea.oncopy = function(event) {
    // copy without console prompt
    event.preventDefault();
    var txt = newTextArea.value.substring(newTextArea.selectionStart, newTextArea.selectionEnd);
    txt = txt.replaceAll('msf> ', '');
    event.clipboardData.setData('text/plain', txt);
  }
  attack_step_div.appendChild(newTextArea);
}

// switch the attack step menu
function onAttackPathStepSelected() {
  var tab_number = this.getAttribute('tab_number');
  var step = this.getAttribute('step');
  var option = this.value;
  var attack_step_text_item = attack_step_texts.find((v) =>
    v.tab_number == tab_number &&
    v.step == step &&
    v.option == option);
  var attackStepTextArea = document.getElementById('TAB_' + tab_number + '_step_' + step);
  attackStepTextArea.value = attack_step_text_item.attack_text;
}

function makeAttackingParamaetersMenu(hosts) {
  var attacking_host = document.getElementById('attacking_host');
  var target_host = document.getElementById('target_host');
  var newOption = document.createElement('option');
  newOption.text = '';
  newOption.value = '';
  newOption.style.fontSize = '1.1vw';
  target_host.appendChild(newOption);
  var active_hosts = hosts.filter((v) => v.passive_flag == false);
  for (host_item of active_hosts) {
    var host = host_item.host;
    var newOption = document.createElement('option');
    newOption.text = host;
    newOption.value = host;
    newOption.style.fontSize = '1.2vw';
    var lowerText = host.toLowerCase();
    if (lowerText.search(/attacker/) != -1) {
      newOption.selected = true;
    }
    attacking_host.appendChild(newOption);
    var newOption2 = document.createElement('option');
    newOption2.text = host;
    newOption2.value = host;
    newOption2.style.fontSize = '1.1vw';
    target_host.appendChild(newOption2);
  }
  var target_state = document.getElementById('target_state');
  target_host.onchange = function() {
    // if target_host is set, disable target_state
    target_state.disabled = !!(target_host.options[target_host.options.selectedIndex].value);
  }
}

// constants
const nwg_unit_size = 8; // pixel
const nwg_canvas_padding = 2;
const nwg_sw_margin = 2;
const nwg_sw_height = 4; //even number only
const nwg_active_host_height = 8; //even number only
const nwg_active_host_width = 16; //even number only
const nwg_active_host_margin = 6; //even number only
const nwg_text_size = 1.6;
var nwg_active_host_and_margin_half_width = (nwg_active_host_width + nwg_active_host_margin) / 2;

function guessAttacker(hosts) {
  var attackerHost = null;
  var e = document.getElementById('attacking_host');
  if (e && e.options && e.options.selectedIndex >= 0) {
    var hostName = e.options[e.options.selectedIndex].value.toLowerCase();
    attackerHost = hosts.find((v) => v.host.toLowerCase() == hostName);
  }
  if (!attackerHost) {
    attackerHost = hosts.find((v) => v.host.toLowerCase().search(/attacker/) != -1);
  }
  return attackerHost;
}

function analyzeNetworkGraph(networkGraph_xml) {
  // procedure 1-1
  var hosts_and_nodes = createHostsAndNodes(networkGraph_xml);
  var hosts = hosts_and_nodes.hosts;
  var nodes = hosts_and_nodes.nodes;
  // procedure 1-2 read connections
  var connections_list = network_xml_dom_.getElementsByTagName('connections');
  if (connections_list.length == 0) {
    alert("Error in analyzeNetworkGraph(): connections list not found");
    return null;
  }
  var connection_list = connections_list[0].getElementsByTagName('connection');
  for (new_connection of connection_list) {
    var node1_id;
    var node2_id;
    var attr_begin = new_connection.getAttribute('begin');
    var attr_end = new_connection.getAttribute('end');
    if (attr_begin) {
      node1_id = attr_begin.toLowerCase();
    }
    else {
      alert('Error in analyzeNetworkGraph(): connections begin not found');
      continue;
    }
    if (attr_end) {
      node2_id = attr_end.toLowerCase();
    }
    else {
      alert('Error in analyzeNetworkGraph(): connections end not found');
      continue;
    }
    var node1 = nodes.find((v) => v.interface === node1_id);
    var node2 = nodes.find((v) => v.interface === node2_id);
    if (node1 == undefined) {
      alert('Error in analyzeNetworkGraph(): host: ' + node1_id + ' in connections not found');
      continue;
    }
    if (node2 == undefined) {
      alert('Error in analyzeNetworkGraph(): host: ' + node2_id + ' in connections not found');
      continue;
    }
    node1.connected_nodes.push(node2_id);
    node2.connected_nodes.push(node1_id);
  }
  // check the all interfaces are connected
  var alone_nodes = nodes.filter((v) => v.connected_nodes.length == 0);
  if (alone_nodes.length > 0) {
    for (alone_node_item of alone_nodes) {
      alert('Error in analyzeNetworkGraph(): node: ' + alone_node_item.interface + ' has no connection');
    }
  }
  // procedure 1-3..1-6
  var attacker = guessAttacker(hosts); // hosts.find((v) => v.host.toLowerCase().search(/attacker/) != -1);
  if (attacker == undefined) {
    alert("Error in analyzeNetworkGraph(): attacker not found");
    return null;
  }
  var last_sw_id = [];
  attacker.columun = 0;
  var current_columun = 0;
  var direct_connection_found = false;
  do {
    var hosts_in_columun;
    if (direct_connection_found) {
      hosts_in_columun = hosts.filter((v) => v.columun == -2);
      direct_connection_found = false;
    } else {
      hosts_in_columun = hosts.filter((v) => v.columun == current_columun);
      if (hosts_in_columun.length == 0) {
        // last sw
        if (last_sw_id.length != 0) {
          var last_sw = last_sw_id.pop();
          var last_host = hosts.find((v) => v.host === last_sw);
          last_host.columun = current_columun;
          hosts_in_columun.push(last_host);
        } else {
          break;
        }
      }
    }
    for (current_host of hosts_in_columun) {
      if (current_host.columun == -2) {
        current_host.columun = current_columun;
      }
      var current_nodes_list = [];
      if (current_host.passive_flag) {
        current_nodes_list = nodes.filter((v) => (v.host === current_host.host));
      } else {
        // exclude upper nodes
        current_nodes_list = nodes.filter((v) => (v.host === current_host.host)
          && (!current_host.upper_interfaces.includes(v.interface)));
      }
      for (current_node of current_nodes_list) {
        current_host.lower_interfaces.push(current_node.interface);
        for (connected_node of current_node.connected_nodes) {
          var lower_node = nodes.find((v) => v.interface === connected_node);
          var lower_host = hosts.find((v) => v.host === lower_node.host);
          if (lower_host.columun == -1) {
            current_host.lower_nodes.push(lower_node.interface);
            lower_host.upper_interfaces.push(lower_node.interface);
            lower_host.upper_nodes.push(current_node.interface);
            // check direct connection between two active hosts
            if ((!current_host.passive_flag) && (!lower_host.passive_flag)) {
              lower_host.direct_connection_num = current_host.direct_connection_num + 1;
              lower_host.columun = -2;// process in the next cicle
              direct_connection_found = true;
            } else {
              // check the tree structure
              if (lower_host.passive_flag && (hosts.find((v) => v.columun == (current_columun + 1)) != undefined)) {
                if (!last_sw_id.includes(lower_host.host)) {
                  last_sw_id.push(lower_host.host);
                }
              } else {
                lower_host.columun = current_columun + 1;
                if (last_sw_id.includes(lower_host.host)) {
                  last_sw_id.splice(last_sw_id.indexOf(lower_host.host));
                }
              }
            }
          } else if ((!current_host.passive_flag) && (!lower_host.passive_flag)) {
            alert('Error in analyzeNetworkGraph(): active host: '
              + current_host.host + ' cannot have more than one direct connection');
            return null;
          } else if (lower_host.columun == (current_columun + 1)) {
            current_host.lower_nodes.push(lower_node.interface);
            if (!lower_host.passive_flag) { lower_host.upper_interfaces.push(lower_node.interface); }
            lower_host.upper_nodes.push(current_node.interface);
          } else if (lower_host.columun < current_columun) {
            if (!current_host.passive_flag) {
              alert("Error in analyzeNetworkGraph(2)"); // unreachable
            }
          }
        }
      }
    }
    if (direct_connection_found) {
      continue;
    }
    current_columun++;
    if (current_columun >= 1000000) {
      alert("Error in analyzeNetworkGraph(3)"); // unreachable
      break;
    }
  }
  while ((hosts.filter((v) => v.columun == -1).length > 0) || (last_sw_id.length > 0) || direct_connection_found);
  var num_of_columun = hosts.reduce((a, b) => a.columun > b.columun ? a : b).columun + 1;
  var canvas_width = 0;
  var canvas_height = 0;
  // procedure 2
  var top_y_of_current_columun = nwg_canvas_padding;
  for (current_columun = 0; current_columun < num_of_columun; current_columun++) {
    var current_columun_height = 0;
    var direct_connection_in_columun = 0;
    var hosts_in_columun = hosts.filter((v) => v.columun == current_columun);
    for (current_host of hosts_in_columun) {
      if (current_host.passive_flag) {
        current_host.top_y = top_y_of_current_columun;
        if (current_columun_height < nwg_sw_height) {
          current_columun_height = nwg_sw_height;
        }
      } else {
        // active host
        if (current_host.direct_connection_num != 0) {
          current_host.top_y = top_y_of_current_columun +
            (nwg_active_host_height + nwg_sw_height) * current_host.direct_connection_num;
          if (direct_connection_in_columun < current_host.direct_connection_num) {
            direct_connection_in_columun = current_host.direct_connection_num;
            current_columun_height = (nwg_active_host_height + nwg_sw_height)
              * (current_host.direct_connection_num + 1)
          }
        } else {
          current_host.top_y = top_y_of_current_columun;
          if (current_columun_height < nwg_active_host_height + nwg_sw_height) {
            current_columun_height = nwg_active_host_height + nwg_sw_height;
          }
        }
      }
    }
    top_y_of_current_columun += current_columun_height;
  }
  canvas_height = top_y_of_current_columun - nwg_sw_height + nwg_canvas_padding;
  // procedure 3
  // active hosts
  // check the max number of hosts in a columun
  var max_host_num_in_columun = 0;
  var host_num_in_columun = [];
  for (current_columun = 0; current_columun < num_of_columun; current_columun++) {
    var host_num_in_current_columun = 0;
    if (current_columun & 1) {
      host_num_in_columun.push(host_num_in_current_columun);
      continue;
    }
    var hosts_in_columun = hosts.filter((v) => v.columun == current_columun);
    for (current_host of hosts_in_columun) {
      var is_connect_to_far_sw = false;
      for (lower_node_item of current_host.lower_nodes) {
        var lower_host = nodes.find((v) => v.interface === lower_node_item).host;
        if (hosts.find((v) => v.host === lower_host).columun != (current_columun + 1)) {
          is_connect_to_far_sw = true;
          break;
        }
      }
      if (!is_connect_to_far_sw) {
        host_num_in_current_columun++;;
      }
    }
    host_num_in_columun.push(host_num_in_current_columun);
    if (host_num_in_current_columun > max_host_num_in_columun) {
      max_host_num_in_columun = host_num_in_current_columun;
    }
  }
  var midst_left_x = nwg_active_host_and_margin_half_width * (max_host_num_in_columun - 1)
    + nwg_canvas_padding + nwg_sw_margin;
  var hosts_between_far_switches = [];
  for (current_columun = 0; current_columun < num_of_columun; current_columun++) {
    var hosts_in_columun = hosts.filter((v) => v.columun == current_columun).sort((a, b) =>
      a.direct_connection_num - b.direct_connection_num);
    if (hosts_in_columun[0].passive_flag) { continue; }
    var left_x_of_current_columun = midst_left_x -
      (host_num_in_columun[current_columun] - 1) * nwg_active_host_and_margin_half_width
      + (current_columun & 2) / 2;
    for (current_host of hosts_in_columun) {
      var is_connect_to_far_sw = false;
      for (lower_node_item of current_host.lower_nodes) {
        var lower_host = nodes.find((v) => v.interface === lower_node_item).host;
        var lower_host_columun = hosts.find((v) => v.host === lower_host).columun
        if ((lower_host_columun != current_columun + 1) && (lower_host_columun != current_columun)) {
          is_connect_to_far_sw = true;
          break;
        }
      }
      if (is_connect_to_far_sw) {
        hosts_between_far_switches.push(current_host.host);
      } else {
        if (current_host.direct_connection_num > 0) {
          var upper_node = nodes.find((v) => v.interface === current_host.upper_nodes[0]);
          var upper_host = hosts.find((v) => v.host === upper_node.host);
          if (upper_host.lower_interfaces.length > 1) {
            current_host.left_x = upper_host.left_x + nwg_active_host_width / 2 + 2;
          } else {
            current_host.left_x = upper_host.left_x;
          }
        } else {
          current_host.left_x = left_x_of_current_columun;
          left_x_of_current_columun += nwg_active_host_width + nwg_active_host_margin;
        }
      }
    }
  }
  var left_x_of_far_switches_area = max_host_num_in_columun
    * (nwg_active_host_width + nwg_active_host_margin) + nwg_active_host_margin;
  var last_host_columun = -1;
  for (current_host_between_far_switches of hosts_between_far_switches) {
    temp_host = hosts.find((v) => v.host === current_host_between_far_switches);
    if (last_host_columun == -1) {
      // the first host
    } else if (temp_host.columun == last_host_columun) {
      left_x_of_far_switches_area += nwg_active_host_width + nwg_active_host_margin;
    } else {
      left_x_of_far_switches_area += nwg_active_host_and_margin_half_width;
    }
    temp_host.left_x = left_x_of_far_switches_area;
    last_host_columun = temp_host.columun;
  }
  // sets positions of nodes
  var active_hosts = hosts.filter((v) => v.passive_flag == false);
  for (current_host of active_hosts) {
    // upper interfaces
    var num_of_upper_interfaces = Math.min(current_host.upper_interfaces.length, 3);
    var current_node_x = current_host.left_x + nwg_active_host_width / 2 - (num_of_upper_interfaces - 1);
    var num_of_nodes = 0;
    for (current_interface of current_host.upper_interfaces) {
      if ((current_host.passive_flag == false) && (num_of_nodes >= 3)) {
        alert('Error in analyzeNetworkGraph(): host: ' + current_host.host +
          ' has more than 3 upper interfaces. Some of them are omitted.');
        break;
      }
      var temp_interface = nodes.find((v) => v.interface === current_interface);
      if (current_host.direct_connection_num > 0) {
        if (num_of_nodes >= 2) {
          alert('Error in analyzeNetworkGraph(): host: ' + current_host.host +
            ' has undrawable upper interfaces. Some of them are not displayed properly.');
        }
        var connected_node = nodes.find((v) => v.interface === temp_interface.connected_nodes[0]);
        if (connected_node.passive_flag == false) {
          //direct connection
          var connected_host = hosts.find((v) => v.host === connected_node.host);
          temp_interface.node_x = (current_host.left_x + connected_host.left_x + nwg_active_host_width) / 2; // average
        } else {
          // connected to sw
          temp_interface.node_x = current_host.left_x + nwg_active_host_width / 2; // center
        }
      } else {
        temp_interface.node_x = current_node_x;
        current_node_x += 2;
      }
      temp_interface.node_y = current_host.top_y;
      num_of_nodes++;
    }
    // lower interfaces
    var num_of_lower_interfaces = Math.min(current_host.lower_interfaces.length, 3);
    var current_node_x = current_host.left_x + nwg_active_host_width / 2 - (num_of_lower_interfaces - 1);
    num_of_nodes = 0;
    // check direct connection
    var lower_direct_connection_flag = false;
    for (lower_inteface_item of current_host.lower_interfaces) {
      var lower_interface_node = nodes.find((v) => v.interface === lower_inteface_item);
      var lower_connected_node = nodes.find((v) => v.interface === lower_interface_node.connected_nodes[0]);
      if (lower_connected_node == undefined) {
        continue;
      }
      if (lower_connected_node.passive_flag == false) {
        lower_direct_connection_flag = true;
        break;
      }
    }
    for (current_interface of current_host.lower_interfaces) {
      if ((current_host.passive_flag == false) && (num_of_nodes >= 3)) {
        alert('Error in analyzeNetworkGraph(): host: ' + current_host.host +
          ' has more than 3 lower interfaces. Some of them are omitted.');
        break;
      }
      var temp_interface = nodes.find((v) => v.interface === current_interface);
      if (lower_direct_connection_flag) {
        if (num_of_nodes >= 2) {
          alert('Error in analyzeNetworkGraph(): host: ' + current_host.host +
            ' has undrawable upper interfaces. Some of them are not displayed properly.');
        }
        var connected_node = nodes.find((v) => v.interface === temp_interface.connected_nodes[0]);
        if (connected_node.passive_flag == false) {
          //direct connection
          var connected_host = hosts.find((v) => v.host === connected_node.host);
          temp_interface.node_x = (current_host.left_x + connected_host.left_x + nwg_active_host_width) / 2; // average
        } else {
          // connected to sw
          temp_interface.node_x = current_host.left_x + nwg_active_host_width / 2; // center
        }
      } else {
        temp_interface.node_x = current_node_x;
        current_node_x += 2;
      }
      temp_interface.node_y = current_host.top_y + nwg_active_host_height;
      num_of_nodes++;
    }
  }
  // procedure 4
  // sw
  var passive_hosts = hosts.filter((v) => v.passive_flag == true);
  for (current_host of passive_hosts) {
    var left_end_x = 100000;
    var right_end_x = 0;
    for (upper_node_item of current_host.upper_nodes) {
      var temp_node = nodes.find((v) => v.interface === upper_node_item);
      var upper_host = hosts.find((v) => v.host === temp_node.host);
      if (upper_host == undefined) { continue; }
      if (upper_host.left_x < left_end_x) {
        left_end_x = upper_host.left_x;
      }
      if (upper_host.left_x > right_end_x) {
        right_end_x = upper_host.left_x;
      }
    }
    for (lower_node_item of current_host.lower_nodes) {
      var temp_node = nodes.find((v) => v.interface === lower_node_item);
      var lower_host = hosts.find((v) => v.host === temp_node.host);
      if (lower_host == undefined) { continue; }
      if (lower_host.left_x < left_end_x) {
        left_end_x = lower_host.left_x;
      }
      if (lower_host.left_x > right_end_x) {
        right_end_x = lower_host.left_x;
      }
    }
    current_host.left_x = left_end_x - nwg_sw_margin;
    current_host.right_x = right_end_x + nwg_active_host_width + nwg_sw_margin;
    if (current_host.right_x > canvas_width) {
      canvas_width = current_host.right_x;
    }
  }
  if (hosts.filter((v) => v.passive_flag == true).length == 0) {
    canvas_width = hosts.reduce((a, b) => a.left_x > b.left_x ? a : b).left_x + nwg_active_host_width + 2;
  }
  canvas_width += nwg_canvas_padding;
  return { hosts: hosts, nodes: nodes, canvas_width: canvas_width, canvas_height: canvas_height };
}

function drawNetworkGraph(canvas_id, graph_parameters) {
  // procedure 5
  var network_canvas = document.getElementById(canvas_id);
  var network_canvas_context = network_canvas.getContext('2d');
  network_canvas.height = graph_parameters.canvas_height * nwg_unit_size;
  network_canvas.width = graph_parameters.canvas_width * nwg_unit_size;
  network_canvas.style.backgroundColor = '#e5effd';
  drawHosts(network_canvas_context, graph_parameters.hosts, graph_parameters.nodes);
  drawSw(network_canvas_context, graph_parameters.hosts, graph_parameters.nodes);
}

const nwg_border_color = 'rgb(10,76,174)';
const nwg_fill_color = 'rgb(34,118,242)';
const nwg_text_style = '"Segoe UI", "DejaVu Sans Mono", sans-serif';
const nwg_text_color = 'white';
const nwg_text_shadow_color = 'rgba(0, 0, 0, 0.6)';
const nwg_sw_text_color = 'black';
const nwg_sw_text_style = '"Segoe UI", "DejaVu Sans Mono", sans-serif';
const nwg_border_width = 2;

function drawHosts(canvas_context, hosts, nodes) {
  // draw rectangles
  canvas_context.strokeStyle = nwg_border_color;
  canvas_context.fillStyle = nwg_fill_color;
  canvas_context.lineWidth = nwg_border_width;
  var active_hosts = hosts.filter((v) => v.passive_flag == false);
  for (current_host of active_hosts) {
    if (current_host.left_x == -1 || current_host.top_y == -1) { continue; }
    canvas_context.fillRect(
      current_host.left_x * nwg_unit_size,
      current_host.top_y * nwg_unit_size,
      nwg_active_host_width * nwg_unit_size,
      nwg_active_host_height * nwg_unit_size);
    canvas_context.strokeRect(
      current_host.left_x * nwg_unit_size,
      current_host.top_y * nwg_unit_size,
      nwg_active_host_width * nwg_unit_size,
      nwg_active_host_height * nwg_unit_size);
  }
  // draw text
  canvas_context.fillStyle = nwg_text_color;
  canvas_context.shadowColor = nwg_text_shadow_color;
  canvas_context.shadowOffsetX = 3;
  canvas_context.shadowOffsetY = 3;
  canvas_context.shadowBlur = 5;
  canvas_context.textAlign = "center";
  canvas_context.textBaseline = "top";
  for (current_host of active_hosts) {
    if (current_host.left_x == -1 || current_host.top_y == -1) { continue; }
    var lines = 1 + current_host.upper_interfaces.length + current_host.lower_interfaces.length;
    var text_y;
    var text_height;
    if (lines < 4) {
      text_height = (nwg_active_host_height * nwg_unit_size - nwg_border_width * 2) / 4;
      text_y = current_host.top_y * nwg_unit_size + nwg_border_width + text_height * (2.2 - lines * 0.5);
    } else {
      text_height = (nwg_active_host_height * nwg_unit_size - nwg_border_width * 2) / lines;
      text_y = current_host.top_y * nwg_unit_size + text_height * 0.3;
    }
    canvas_context.font = text_height * 1.2 + 'px ' + nwg_text_style;
    canvas_context.fillText(current_host.host,
      current_host.left_x * nwg_unit_size + nwg_active_host_width * nwg_unit_size / 2,
      text_y - text_height * 0.5,
      nwg_active_host_width * nwg_unit_size);
    text_y += text_height;
    canvas_context.font = text_height * 0.7 + 'px ' + nwg_text_style;
    for (interface of current_host.upper_interfaces) {
      var ip_address = nodes.find((v) => v.interface === interface).ip_address;
      if (ip_address == null) { continue; }
      canvas_context.fillText(ip_address,
        current_host.left_x * nwg_unit_size + nwg_active_host_width * nwg_unit_size / 2,
        text_y,
        nwg_active_host_width * nwg_unit_size);
      text_y += text_height;
    }
    for (interface of current_host.lower_interfaces) {
      var ip_address = nodes.find((v) => v.interface === interface).ip_address;
      if (ip_address == null) { continue; }
      canvas_context.fillText(ip_address,
        current_host.left_x * nwg_unit_size + nwg_active_host_width * nwg_unit_size / 2,
        text_y,
        nwg_active_host_width * nwg_unit_size);
      text_y += text_height;
    }
  }
  canvas_context.shadowColor = 'rgba(0, 0, 0, 0)';
}

function drawSw(canvas_context, hosts, nodes) {
  //draw interfaces
  canvas_context.strokeStyle = nwg_border_color;
  canvas_context.lineWidth = nwg_border_width;
  active_nodes = nodes.filter((v) => (v.passive_flag == false));
  for (current_node of active_nodes) {
    var connected_sw_node = nodes.find((v) => v.interface === current_node.connected_nodes[0]);
    if (connected_sw_node == undefined) {
      continue;
    }
    canvas_context.beginPath();
    if (connected_sw_node.passive_flag == false) {
      canvas_context.moveTo(current_node.node_x * nwg_unit_size, current_node.node_y * nwg_unit_size);
      canvas_context.lineTo(current_node.node_x * nwg_unit_size, connected_sw_node.node_y * nwg_unit_size);
    } else {
      var connected_sw = hosts.find((v) => v.host === current_node.connected_nodes[0]);
      canvas_context.moveTo(current_node.node_x * nwg_unit_size, current_node.node_y * nwg_unit_size);
      canvas_context.lineTo(current_node.node_x * nwg_unit_size, connected_sw.top_y * nwg_unit_size);
    }
    canvas_context.stroke();
  }
  //draw switches
  canvas_context.strokeStyle = nwg_border_color;
  canvas_context.lineWidth = nwg_border_width;
  var passive_hosts = hosts.filter((v) => v.passive_flag == true);
  for (current_host of passive_hosts) {
    canvas_context.beginPath();
    canvas_context.moveTo(current_host.left_x * nwg_unit_size, current_host.top_y * nwg_unit_size);
    canvas_context.lineTo(current_host.right_x * nwg_unit_size, current_host.top_y * nwg_unit_size);
    canvas_context.stroke();
  }
  canvas_context.fillStyle = nwg_sw_text_color;
  canvas_context.textAlign = "right";
  canvas_context.textBaseline = "bottom";
  canvas_context.font = (nwg_active_host_height * nwg_unit_size / 5) + 'px ' + nwg_sw_text_style;
  for (current_host of passive_hosts) {
    canvas_context.fillText(current_host.host,
      current_host.right_x * nwg_unit_size,
      current_host.top_y * nwg_unit_size - nwg_border_width,
      (nwg_active_host_width / 2 + 1) * nwg_unit_size);
  }
}

function createHostsAndNodes(networkGraph_xml) {
  var new_hosts = [];
  var new_nodes = [];
  var host_list = network_xml_dom_.getElementsByTagName('host');
  for (var host_item of host_list) {
    var new_host = createNewHost();
    var passive_flag;
    if (!host_item.hasAttribute('id')) {
      alert('Error in createHostsAndNodes(): a host has no id');
      continue;
    }
    var host_id = host_item.id;
    if (host_id == '') {
      alert('Error in createHostsAndNodes(): a host has no id');
      continue;
    }
    new_host.host = host_id.toLowerCase();
    if (!host_item.hasAttribute('passive')) {
      alert('Error in createHostsAndNodes(): host: ' + new_host.host + ' has no valid passive flag. assumed as "false".');
      passive_flag = false;
    } else {
      passive_flag = host_item.getAttribute('passive').toLowerCase();
      if (!(passive_flag == 'true' || passive_flag == 'false')) {
        alert('Error in createHostsAndNodes(): host: ' + new_host.host + ' has no valid passive flag. assumed as "false".');
      }
    }
    new_host.passive_flag = (passive_flag == 'true');
    new_hosts.push(new_host);
    if (new_host.passive_flag) {
      var new_node = createNewNode();
      new_node.interface = host_item.id.toLowerCase();
      new_node.passive_flag = true;
      new_node.host = host_item.id.toLowerCase();
      new_nodes.push(new_node);
    } else {
      var interfaces_list = host_item.getElementsByTagName('interfaces');
      if (interfaces_list.length == 0) {
        alert('Error in createHostsAndNodes(): active host: ' + new_host.host + ' has no interface');
        continue;
      }
      var interface_list = interfaces_list[0].getElementsByTagName('interface');
      for (new_interface of interface_list) {
        var new_node = createNewNode();
        var node_id = new_interface.id;
        if (node_id == '') {
          alert('Error in createHostsAndNodes(): a node has no interface id');
          continue;
        }
        new_node.interface = node_id.toLowerCase();
        new_node.host = new_host.host;
        new_node.passive_flag = false;
        new_node.ip_address = new_interface.getAttribute('ip');
        new_nodes.push(new_node);
      }
    }
  }
  return { hosts: new_hosts, nodes: new_nodes };
}

function createNewHost() {
  var new_upper_interfaces = [];
  var new_lower_interfaces = [];
  var new_upper_nodes = [];
  var new_lower_nodes = [];
  var new_host = {
    passive_flag: true,
    host: '',
    columun: -1,
    upper_interfaces: new_upper_interfaces,
    lower_interfaces: new_lower_interfaces,
    upper_nodes: new_upper_nodes,
    lower_nodes: new_lower_nodes,
    direct_connection_num: 0,
    left_x: -1,
    right_x: -1,
    top_y: -1,
  };
  return new_host;
}

function createNewNode() {
  var new_connected_nodes = [];
  var new_node = {
    interface: '',
    host: '',
    passive_flag: true,
    connected_nodes: new_connected_nodes,
    ip_address: '',
    node_x: -1,
    node_y: -1,
  }
  return new_node;
}

var last_tab_number;

function analyzeAndDrawAttackPath(attack_paths, graph_parameters) {
  var hosts = graph_parameters.hosts;
  var nodes = graph_parameters.nodes;
  var tab_number = 1;
  var tab_checked = 1;
  attack_step_texts = [];
  last_tab_number = 0;
  initArrowColorPalette();
  for (dict of attack_paths) {
    var current_canvas_id = 'network_attack' + tab_number;
    var current_div_id = 'attack_step_TAB_' + tab_number;
    var current_tab_id = 'TAB_' + tab_number;
    addTab('sc_tabs', current_tab_id, 'TAB_h', 'Attack Path ' + NumToAlpha(tab_number) + " ("+ dict.score.combined + ") ", tab_checked,
      'network_attack_div' + tab_number, current_canvas_id, current_div_id, tab_number);
    //let append_string = '<div id="' + current_div_id + '" style="display: none"/>';
    //$('#attack_step').append(append_string);
    // draw network graph
    drawNetworkGraph(current_canvas_id, graph_parameters);
    var hops = [];
    var attack_step = 1;
    var current_host = guessAttacker(hosts); // hosts.find((v) => v.host.search(/attacker/) != -1);
    var errorMessage = "";
    for (dict_hop of dict.hops) {
      // find ip address
      var ip_address;
      var hop_end_host;
      var ip_address_found = false;
      if (dict_hop.node) {
        hop_end_host = dict_hop.node.toLowerCase();
      }
      else {
        if (errorMessage == "") {
          errorMessage = "Error in analyzeAttackPath(): Attack Path "
            + NumToAlpha(attack_paths.indexOf(dict) + 1) + ": node not found in hop";
        }
        break;
      }

      for (option of dict_hop.options) {
        for (action of option.actions) {
          if (action.value) {
            var values = action.value.toLowerCase().split(' ');
            var rhost = values.find((v) => v.indexOf('rhosts=') == 0 || v.indexOf('rhost=') == 0 );
            if (rhost == undefined) { continue; }
            ip_address_found = true;
            var rhost_ip = rhost.substr(rhost.indexOf('=') + 1);
            ip_address = rhost_ip.toLowerCase();
          }
          break;
        }
        if (ip_address_found) { break; }
      }
      if (!ip_address_found) {
        if (errorMessage == "") {
          errorMessage = "Error in analyzeAttackPath(): Attack Path "
            + NumToAlpha(attack_paths.indexOf(dict) + 1) + ": IP address not found in hop :" + dict_hop.node;
        }
      }
      else {
        var new_hop = createNewHop();
        new_hop.end_host = hop_end_host;
        if (ip_address_found) {
          var next_node = nodes.find((v) => (v.ip_address === ip_address) && (v.host === new_hop.end_host));
          if (next_node == undefined) {
            if (errorMessage == "") {
              errorMessage = 'Error in analyzeAttackPath(): Attack Path '
                + NumToAlpha(attack_paths.indexOf(dict) + 1) + ': cannot hop to ' + dict_hop.node;
            }
          }
          else {
            new_hop.end_interface = next_node.interface;
            var current_interfaces;
            if (current_host.upper_interfaces.length > 0) {
              current_interfaces = current_host.upper_interfaces.concat(current_host.lower_interfaces);
            } else {
              current_interfaces = current_host.lower_interfaces;
            }
            if (current_interfaces.includes(next_node.connected_nodes[0])) {
              // direct connection
              new_hop.start_interface = next_node.connected_nodes[0];
            } else {
              new_hop.sw = next_node.connected_nodes[0];
              var start_interface = nodes.find((v) => (v.host === current_host.host)
                && (v.connected_nodes[0] === new_hop.sw));
              if (start_interface == undefined) {
                if (errorMessage == "") {
                  errorMessage = "Error in analyzeAttackPath(): Attack Path "
                    + NumToAlpha(attack_paths.indexOf(dict) + 1) + ": connection to node:" + dict_hop.node + ' not found';
                }
              }
              else {
                new_hop.start_interface = start_interface.interface;
              }
            }
            if ((errorMessage == "") && (new_hop.start_interface != "")) {
              hops.push(new_hop);
            }
          }
        }
      }
      addAttackPathStep(tab_number, current_div_id, current_host, dict_hop, attack_step);
      attack_step++;
      current_host = hosts.find((v) => v.host === hop_end_host);
      if (current_host == undefined) {
        if (errorMessage == "") {
          errorMessage = "Error in analyzeAttackPath(): Attack Path "
            + NumToAlpha(attack_paths.indexOf(dict) + 1) + ": host: " + hop_end_host + " not found in hop";
        }
        break;
      }
    }

    if (errorMessage == "") {
      var attack_canvas = document.getElementById(current_canvas_id);
      drawAttacks(attack_canvas.getContext('2d'), hops, hosts, nodes, tab_number - 1);
    }
    else {
      alert(errorMessage);
    }

    // display 1st attack path
    last_tab_number = 1;
    if (tab_checked == 1) {
      var current_div = document.getElementById(current_div_id);
      current_div.style.display = 'inline-block';
    }
    tab_checked = 0;
    tab_number++;
  }
}

// switch the attack step menu
function onTabClick(tab_number) {
  if (tab_number == last_tab_number) { return; }
  var last_div_id = 'attack_step_TAB_' + last_tab_number;
  var last_div = document.getElementById(last_div_id);
  var new_div_id = 'attack_step_TAB_' + tab_number;
  var new_div = document.getElementById(new_div_id);
  last_div.style.display = 'none';
  new_div.style.display = 'inline-block';
  last_tab_number = tab_number;
}

function drawAttacks(canvas_context, hops, hosts, nodes, color_palette) {
  var delta = [];
  var initial_pos;
  var last_sw = '';
  color_palette %= attack_path_color_base.length;
  for (hop_item of hops) {
    var start_node = nodes.find((v) => v.interface === hop_item.start_interface);
    if ((last_sw != hop_item.sw) || (last_sw == '')) {
      if (delta.length != 0) {
        drawPath(canvas_context, color_palette, initial_pos, delta);
        delta.length = 0;
      }
      initial_pos = { x: start_node.node_x * nwg_unit_size, y: start_node.node_y * nwg_unit_size };
    } else {
      delta.push(0);
    }
    var end_node = nodes.find((v) => v.interface === hop_item.end_interface);
    if (hop_item.sw == '') {
      // direct connection
      delta.push((end_node.node_y - start_node.node_y) * nwg_unit_size);
      last_sw = '';
    } else {
      var sw = hosts.find((v) => v.host === hop_item.sw);
      delta.push((sw.top_y - start_node.node_y) * nwg_unit_size);
      delta.push((end_node.node_x - start_node.node_x) * nwg_unit_size);
      delta.push((end_node.node_y - sw.top_y) * nwg_unit_size);
      last_sw = sw.host;
    }
  }
  if (delta.length != 0) {
    drawPath(canvas_context, color_palette, initial_pos, delta);
  }
}

var attack_path_color_base = [
  [241, 65, 17],
  [6, 186, 160],
  [194, 18, 236],
  [72, 191, 250],
  [248, 198, 38],
  [147, 147, 153],
];

var arrow_width = 3;
var border_width = 3;
var anchor_size = 7;
var draw_offset = 4;
var corner_size = 5;
var attack_path_color_stroke = [];
var attack_path_color_border = [];

function initArrowColorPalette() {
  for (var base_color of attack_path_color_base) {
    var stroke_color = [];
    var border_color = [];
    if (true) {
      stroke_color = [...base_color];
      border_color = [
        Math.min(base_color[0] + 150, 255),
        Math.min(base_color[1] + 150, 255),
        Math.min(base_color[2] + 150, 255),
      ];
    } else {
      stroke_color = [
        Math.min(base_color[0] * 1.5, 255),
        Math.min(base_color[1] * 1.5, 255),
        Math.min(base_color[2] * 1.5, 255),
      ];
      border_color = [
        Math.min(base_color[0] * 0.75, 255),
        Math.min(base_color[1] * 0.75, 255),
        Math.min(base_color[2] * 0.75, 255),
      ];
    }
    var temp_color_stroke = 'rgb(' + stroke_color[0] + ',' + stroke_color[1] + ',' + stroke_color[2] + ')'
    var temp_color_border = 'rgb(' + border_color[0] + ',' + border_color[1] + ',' + border_color[2] + ')'
    attack_path_color_stroke.push(temp_color_stroke);
    attack_path_color_border.push(temp_color_border);
  }
}

function drawArrow(canvas_context, color_palette, arrow_flag, anchor) {
  canvas_context.lineJoin = 'round';
  canvas_context.lineCap = 'round';
  canvas_context.strokeStyle = attack_path_color_border[color_palette];
  canvas_context.fillStyle = attack_path_color_border[color_palette];
  canvas_context.lineWidth = arrow_width + border_width;
  drawLines(canvas_context, anchor);
  if (arrow_flag) {
    drawAnchor(canvas_context, anchor, anchor_size + border_width);
  }
  canvas_context.strokeStyle = attack_path_color_stroke[color_palette];
  canvas_context.fillStyle = attack_path_color_stroke[color_palette];
  canvas_context.lineWidth = arrow_width;
  drawLines(canvas_context, anchor);
  if (arrow_flag) {
    drawAnchor(canvas_context, anchor, anchor_size);
  }
}

function drawLines(canvas_context, anchor) {
  var anchor2 = [...anchor];
  canvas_context.beginPath();
  var start_pos = anchor2.shift();
  canvas_context.moveTo(start_pos.x, start_pos.y);
  for (var pos of anchor2) {
    canvas_context.lineTo(pos.x, pos.y);
  }
  canvas_context.stroke();
}

function drawAnchor(canvas_context, anchor, anchor_size) {
  var anchor2 = [...anchor];
  var centor_pos = anchor2.pop();
  var last_pos = anchor2.pop();
  var angle;
  if (centor_pos.x == last_pos.x) {
    if (centor_pos.y < last_pos.y) {
      angle = 1.5 * Math.PI;
    }
    else {
      angle = 0.5 * Math.PI;
    }
  } else {
    angle = Math.atan2(centor_pos.y - last_pos.y, centor_pos.x - last_pos.x);
  }
  var angle2 = angle + 0.75 * Math.PI;
  var angle3 = angle - 0.75 * Math.PI;
  canvas_context.beginPath();
  canvas_context.moveTo(centor_pos.x + Math.cos(angle) * anchor_size, centor_pos.y + Math.sin(angle) * anchor_size);
  canvas_context.lineTo(centor_pos.x + Math.cos(angle2) * anchor_size, centor_pos.y + Math.sin(angle2) * anchor_size);
  canvas_context.lineTo(centor_pos.x + Math.cos(angle3) * anchor_size, centor_pos.y + Math.sin(angle3) * anchor_size);
  canvas_context.fill();
}

function drawPath(canvas_context, color_palette, initial_pos, delta) {
  var anchor = [];
  var current_graph_pos;
  var current_draw_pos;
  var current_delta;
  var next_graph_pos;
  var next_delta;
  current_graph_pos = initial_pos;
  if (delta.length == 0) {
    alert('drawPath error 1');
    return;
  }
  current_delta = delta.shift();
  // ============================
  //        first move
  // ============================
  // move up or down
  current_draw_pos = {
    x: current_graph_pos.x - draw_offset * Math.sign(current_delta),
    y: current_graph_pos.y
  };
  anchor.push(current_draw_pos);
  while (true) {
    // ============================
    //        vertical move
    // ============================
    next_graph_pos = { x: current_graph_pos.x, y: current_graph_pos.y + current_delta };
    if (delta.length == 0) {
      // end
      var next_draw_pos = { x: current_draw_pos.x, y: current_graph_pos.y + current_delta };
      anchor.push(next_draw_pos);
      drawArrow(canvas_context, color_palette, true, anchor);
      break;
    }
    next_delta = delta.shift();
    var next_draw_pos1, next_draw_pos2;
    if (next_delta == 0) {
      // turn back
      next_draw_pos1 = { x: current_draw_pos.x, y: current_graph_pos.y + current_delta };
      anchor.push(next_draw_pos1);
      drawArrow(canvas_context, color_palette, false, anchor);
      anchor.length = 0;
      anchor.push(next_draw_pos1);
      next_draw_pos2 = {
        x: next_draw_pos1.x + draw_offset * 2 * Math.sign(current_delta),
        y: next_draw_pos1.y
      };
    }
    else {
      // turn right or left
      next_draw_pos1 = {
        x: current_draw_pos.x,
        y: current_graph_pos.y + current_delta
          - corner_size * Math.sign(current_delta)
          + draw_offset * Math.sign(next_delta)
      };
      next_draw_pos2 = {
        x: current_draw_pos.x
          + corner_size * Math.sign(next_delta),
        y: current_graph_pos.y + current_delta
          + draw_offset * Math.sign(next_delta)
      };
    }
    anchor.push(next_draw_pos1);
    anchor.push(next_draw_pos2);
    current_draw_pos = next_draw_pos2;
    current_graph_pos = next_graph_pos;
    current_delta = next_delta;
    // ============================
    //        horizontal move
    // ============================
    next_graph_pos = { x: current_graph_pos.x + current_delta, y: current_graph_pos.y };
    if (delta.length == 0) {
      // end
      alert("end at h");
      var next_draw_pos = { x: current_draw_pos.x, y: current_graph_pos.y + current_delta };
      anchor.push(next_draw_pos);
      drawArrow(canvas_context, color_palette, true, anchor);
      break;
    }
    next_delta = delta.shift();
    if (next_delta == 0) {
      // turn back
      next_draw_pos1 = { x: current_graph_pos.x + current_delta, y: current_draw_pos.y };
      anchor.push(next_draw_pos1);
      drawArrow(canvas_context, color_palette, false, anchor);
      anchor.length = 0;
      anchor.push(next_draw_pos1);
      next_draw_pos2 = {
        x: next_draw_pos1.x,
        y: next_draw_pos1.y - draw_offset * 2 * Math.sign(current_delta)
      };
    }
    else {
      // turn up or down
      next_draw_pos1 = {
        x: current_graph_pos.x + current_delta
          - corner_size * Math.sign(current_delta)
          - draw_offset * Math.sign(next_delta),
        y: current_draw_pos.y
      };
      next_draw_pos2 = {
        x: current_graph_pos.x + current_delta
          - draw_offset * Math.sign(next_delta),
        y: current_draw_pos.y
          + corner_size * Math.sign(next_delta)
      };
    }
    anchor.push(next_draw_pos1);
    anchor.push(next_draw_pos2);
    current_draw_pos = next_draw_pos2;
    current_graph_pos = next_graph_pos;
    current_delta = next_delta;
  }
}

function createNewHop() {
  var new_hop = {
    end_host: '',
    start_interface: '',
    sw: '',
    end_interface: '',
  }
  return new_hop;
}

function back_to_network_selection() {
  //file_import
  document.getElementById('file_import').style.display = "none";
  document.getElementById('network_disp').style.display = "block";
  document.getElementById('network_attack').style.display = "none";

  //remove callback
  sendServerProgram.init(null, null);
  disableAttackPathDownloadLink();
}

function back_to_top() {
  //file_import
  document.getElementById('file_import').style.display = "block";
  document.getElementById('network_disp').style.display = "none";
  document.getElementById('network_attack').style.display = "none";
  document.getElementById('visualization_xml_text').value = "";
  document.getElementById('route_text').value = "";
  document.getElementById('xml_text').value = "";
  document.getElementById('scan_result_text').value = "";
  document.getElementById('visualization_xml_file').value = "";
  document.getElementById('route_file').value = "";
  document.getElementById('xml_file').value = "";
  document.getElementById('scan_result_file').value = "";
  document.getElementById("visualization_import_button").disabled = true;
  document.getElementById("import_button").disabled = true;
  document.getElementById('back_to_network_button').style.display = "none";

  //network_disp
  document.getElementById('attacking_host').value = "";
  document.getElementById('target_host').value = "";
  document.getElementById('target_state').value = "";
  document.getElementById('target_state').disabled = false;
  document.getElementById("search_button").disabled = false;
  //remove callback
  sendServerProgram.init(null, null);
  disableAttackPathDownloadLink();
}

function reload() {
  //display.legend.location.reload();
}

function reloadPlot() {
  //display.plot.location.reload();
}

function addTab(parent_id, tab_id, tab_name, tab_text, tab_checked, network_attack_div_id, network_attack_canvas_id, attack_step_div_id, tab_number) {
  let appendString = "";
  if (tab_checked === 1) {
    appendString = '<input id="' + tab_id + '" type="radio" name="' + tab_name + '" class="tab-switch" checked="checked" />';
  } else {
    appendString = '<input id="' + tab_id + '" type="radio" name="' + tab_name + '" class="tab-switch" />';
  }
  appendString += '<label class="tab-label" for="' + tab_id + '" onclick="onTabClick(' + tab_number + ')">' + tab_text + '</label>';
  appendString += '<div class="tab-content">';
  appendString += '  <div id="' + network_attack_div_id + '" align="center" style="margin-top: 1.5vh; display: inline-block; vertical-align: top; max-height: 75vh; width: 45vw; overflow: auto;">';
  appendString += '    <canvas id="' + network_attack_canvas_id + '" width="800" height="800"></canvas>';
  appendString += '  </div>';
  appendString += '  <div id="' + attack_step_div_id + '" align="center" style="margin-top: 1.5vh; display: inline-block; vertical-align: top; max-height: 75vh; width: 40vw; overflow: hidden auto;">';
  appendString += '  </div>';
  appendString += '</div>';

  $('#' + parent_id).append(appendString);
}

function callbackDone(res, textStatus, xhr) {
  document.getElementById("search_button").disabled = false;
  document.getElementById('sc_tabs').innerHTML = '';

  var graph_parameters = analyzeNetworkGraph(network_xml_dom_);
  analyzeAndDrawAttackPath(res, graph_parameters);
  document.getElementById('file_import').style.display = 'none';
  document.getElementById('network_disp').style.display = 'none';
  document.getElementById('network_attack').style.display = 'block';
  // enable file download link
  enableAttackPathDownloadLink(xhr.responseText);
}

function callbackFail(xhr, status, errorThrown, resultDetail) {
  document.getElementById("search_button").disabled = false;

  let result = "Error:\n xhr.status=" + xhr.status + "\n xhr.statusText=" + xhr.statusText + "\n status=" + status + "\n errorThrown=" + errorThrown;
  let result_text = result + "\n detail=" + resultDetail;
  alert(result_text);
}

function enableAttackPathDownloadLink(jsonData) {
  var blob = new Blob([jsonData], {type : 'application/json'});
  var url = URL.createObjectURL(blob);
  var link = document.getElementById('download_link');
  document.getElementById('download_link').href = url;
  document.getElementById('download_link_button').style.display = 'inline';
}

function disableAttackPathDownloadLink() {
  var url = document.getElementById('download_link').href;
  document.getElementById('download_link').href = "";
  document.getElementById('download_link_button').style.display = 'none';
  URL.revokeObjectURL(url);
}

function download_attack_paths() {
  document.getElementById('download_link').click();
}

function buttonClickAttackPathSearch() {

  //continuos push prevention
  document.getElementById("search_button").disabled = true;

  //set callback
  sendServerProgram.init(callbackDone, callbackFail);

  //execute attackPathSearch
  sendServerProgram.attackPathSearch("attacking_host", "target_host", "target_state", "xml_file", "scan_result_file");
}

function NumToAlpha(number) {
  let RADIX = 26;
  let A = 'A'.charCodeAt(0);

  let n = number;
  let s = "";
  while (n >= 1) {
    n--;
    s = String.fromCharCode(A + (n % RADIX)) + s;
    n = Math.floor(n / RADIX);
  }
  return s;
}

/********************************************************************************/
/*                             Initialization                                   */
/********************************************************************************/

window.addEventListener('load', init);


/********************************************************************************/
/*                              Finalization                                    */
/********************************************************************************/
window.onunload = function () {
};

/********************************************************************************/
/*                              Window Resize                                   */
/********************************************************************************/

window.addEventListener('resize', reload);

/*********************************** EOF ****************************************/
